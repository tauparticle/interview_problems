Sudoku Solver

Write the function sudokuSolve that checks whether a given sudoku board (i.e. sudoku puzzle) is solvable. If so, the function will returns True. Otherwise (i.e. there is no valid solution to the given sudoku board), returns False.

In sudoku, the objective is to fill a 9x9 board with digits so that each column, each row, and each of the nine 3x3 sub-boards that compose the board contains all of the digits from 1 to 9. The board setter provides a partially completed board, which for a well-posed board has a unique solution. As explained above, for this problem, it suffices to calculate whether a given sudoku board has a solution. No need to return the actual numbers that make up a solution.

A sudoku board is represented in a two dimensional 9x9 array with the numbers 1,2,...,9 and blank spaces, and the function should fill the blank spaces with numbers such that the following rules apply:

In every row of the array, all numbers 1,2,...,9 appear exactly once.
In every column of the array, all numbers 1,2,...,9 appear exactly once.
In every 3x3 sub-board that is illustrated below, all numbers 1,2,...,9 appear exactly once.
A solved sudoku is a board with no blank spaces, i.e. all blank spaces are filled with numbers that abide to the constraints above. If the function succeeds in solving the sudoku board, it'll return true (false, otherwise).

Example (more examples can be found here):

Unsolved Board
A typical Sudoku board setter	 	Solved Board
The same board with solution numbers marked in red
Write a readable an efficient code, explain how it is built and why you chose to build it that way.

Hints & Tips
There are many ways to build a sudoku solver. The most straightforward approach is doing so recursively, in a depth search manner. In each step we pick up one empty cell in the board and try to put any digit that wouldn't cause a constraint violation. If successful, we simply repeat the operation recursively, on a board which has one empty cell less than before. Should this process come to a dead-end, in which there is such a cell in which no digit can be placed lest to cause a violation, we unroll the process back one step and try to replace the last digit with the next viable candidate, if such digit exists; otherwise, we unroll one step more to try next candidate one level further up the line. In perspective, we hope to search all possibilities until a final solution to the Sudoku is found. On the bitter end, we might finish the search without encountering the fully populated board, in which case we simply conclude that initial position was not valid.

But now there appears to be a problem with the solution above. Ask you peer whether they know what it is. A sudoku board contains 81 cells, most of which are initially blank. How many boards should we consider before the solution is found? With every step deeper down the search tree, the number of boards considered becomes larger and larger. In fact, it grows exponentially with depth of the search tree. Going down fifty or so steps into depth sounds quite unfeasible. So what should we do to reduce number of boards generated by the algorithm?

There is one simple heuristic which is applicable to many search problems. At every step we should choose the cell in the board which offers smallest number of candidates, i.e. digits that do not generate collision immediately. By looking for such heavily constrained cells we hope to provoke collisions early in the search, while tree is still shallow and number of nodes reasonably small. When properly applied, this heuristic can cause such tremendous drop in number of search steps that once unfeasible search scheme becomes fast enough to be used in practice. If your peer is still stuck, explain this heuristic to them.

Discuss with your peer how the program is built, through the coding process. Make sure your peer is aware to the runtime issues above. Also, discuss what are edge cases for this program.

Emphasize that your peer is expected to write clean and readable code. Also, recommend your peer to build the code in small blocks and to use auxiliary functions - this will make the process of debugging easier to both of you!

A good followup question is asking how you should test such a program.

Solution
The main idea for the solution is using a recursive algorithm that iterates through the empty squares on the board, and on the possible candidate numbers for each empty square, and tries to fill them, as the following code scheme:

function sudokuSolve(board):
	# Input: board - a sudoku board as described in the question
	# Output: True if the board is solvable

	if (isComplete(board)):
		return True # base case for the recursion

	# get a pair: the row and column of the first empty square in board 
	currentSquareIndex = getFirstEmptySquare(board)
	
	# If the board is full but not completed, it"s invalid
	if (currentSquareIndex == null):
		return False 
		
	row = currentSquareIndex[0]
	col = currentSquareIndex[1]
	candidatesForCurrentSquare = getPossibleCandidates(board, row, col)
	
	for candidate in candidatesForCurrentSquare
		# Assume the current candidate is a good match, and keep solving
		board[row][col] = candidate
		if (sudokuSolve(board)):
			return True

		# The candidate didn"t prove to be good, let"s reset it. Since 0 
		# isn’t a legal value in the board, we can use it to represent 
		# an empty square on the board
		board[row][col] = 0
			
	return False
Where the auxiliary functions are as follows:

function isComplete(board):
	# Input: board - a sudoku board represented as a 9X9 2D array
	# Output: True if the board is complete and legal

	nextEmptySquare = getFirstEmptySquare(board)
	if (nextEmptySquare != null):
		return False
		
	for index from 0 to 8:
		for num from 1 to 9:
			isNumberMissing = !rowContains(board, index, num) or
							!colContains(board, index, num) or 
							!subBoardContains(board, index, num)
							
			if (isNumberMissing):
				return False
				
	# all numbers appear exactly once in each row, column and sub-board
	return True

function getPossibleCandidates(board, row, col):
	# Input: 
	#	board - a sudoku board represented as a 9X9 2D array
	#	row - a row on the board
	#	col - a column on the board
	# Output: 
	#	a subset of the numbers {1,2,...,9}, which may fill the index in the board 
	#	without violating any of the rules described above

	# Build a set containing the numbers 1-9
	LEGAL_NUMBERS = new Set([1,2,3,4,5,6,7,8,9])
	
	numbersUsedInRow = new Set()
	numbersUsedInColumn = new Set();
	
	for i from 0 to 8:
		# Build a set from the row’th row in the board
		numbersUsedInRow.add(board[row][i])
		# Build a set from the col’th column in the board
		numbersUsedInColumn.add(board[i][col])
 
	subBoardTopLeftRow = row - (row % 3)
	subBoardTopLeftColumn = col - (col % 3)
	numbersUsedInSubBoard = new Set()
	
	for i from 0 to 2:
		for j from 0 to 2:
			numUsedInSubBoard = board[subBoardTopLeftRow+i][subBoardTopLeftColumn+j]
			numbersUsedInSubBoard.add(numUsedInSubBoard)
	
	disqualified = new Set()
	disqualified.union(numbersUsedInSubBoard, numbersUsedInRow, numbersUsedInColumn)
	validNumbersForCurrentSquare = LEGAL_NUMBERS.difference(disqualified)
	return validNumbersForCurrentSquare

function getFirstEmptySquare(board):
	# Input: board - a sudoku board represented as a 9X9 2D array
	# Output: An empty square in the board

	for i from 0 to 8:
		for j from 0 to 8:
			if (board[i][j] == 0): # i.e. the square is empty
				# return a a pair of indices (represented as an array of 2)
				return [i,j]
				
	return null


function rowContains(board, row, num):
	# Input: 
	# 	board - a sudoku board represented as a 9X9 2D array
	#	row - the index of a row in the board
	#	num - the number we want to test for
	# Output: True in num is in the index-th row of board

	for col in 0 to 8:
		if (board[row][col] == num):
			return True
			
	return False

function colContains(board, col, num):
	# Input: 
	#	board - a sudoku board represented as a 9X9 2D array
	#	col - the index of a column in the board
	#	num - the number we want to test for
	# Output: True in num is in the index-th column of board

	for row in 0 to 8:
		if (board[row][col] == num):
			return True
			
	return False


function subBoardContains(board, subBoardIndex, num):
	# Input: 
	#	board - a sudoku board represented as a 9X9 2D array
	#	subBoardIndex - the index [0-8] of a 3×3 sub-board in the board
	#		The code assumes that the sub-boards are numbered from
	#		left to right, top to bottom. Examples:
	#		- sub-board at index 0 ranges from (0,0) to (2,2)
	# 		- sub-board at index 5 ranges from (3,6) to (5,8)
	#	num - the number we want to test for
	
	# Output: True in num is in the index-th column of sub-board

	# the row of the top left position in the index-th square of the sub-board
	topLeftPositionRow = subBoardIndex - (subBoardIndex % 3)
	
	# the column of the top left position in the index-th square of the sub-board
	topLeftPositionCol = 3 * (subBoardIndex % 3)

	for i in 0 to 2:
		for j in 0 to 2:
			if (board[topLeftPositionRow + i][topLeftPositionCol + j] == num):
				return True

	return False
As you can see, the function simply goes through all possibilities in a Depth First (DFS) order.

While this code is correct, it is not efficient, since it may go over numerous possibilities for candidates until finally concluding a solution (or a lack of one). One heuristic which may be used to reduce the number of possibilities that the function actually goes through, is trying the indices with the least number of candidates first. This way, if there are collisions, most of the times they are discovered at the first step possible, in this way the whole runtime is usually faster.

One way to implement this is to replace the function getFirstEmptySquare in sudokuSolve with the following function:

function getLeastNumOfCandidatesIndex(board):
	# Input: board - a sudoku board represented as a 9X9 2D array
	# Output: Index of a blank square with the least number of 
	#		  candidates possible (possibly none)

	minIndex = null
	minNumOfCandidates = MAX_INT
	
	for i from 0 to 8:
		for j from 0 to 8:
			numOfCurrentCandidates = size(getPossibleCandidates(i,j))
			if ((board[i][j] == 0) and (numOfCurrentCandidaes < minNumOfCandidates)):
    			minIndex = [i,j]
				numOfMinCandidates = numOfCurrentCandidaes
	
	return minIndex
While there are many ways to improve these results even more, make sure your peer has a reasonable sudoku solver at the end of the interview. Usually, the interviewer prefers a working code which isn’t optimal, over a failed attempt for an optimal function.